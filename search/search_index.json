{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Importable: Overview \u00b6 Simplified Syntax For Importing Project Resources \u00b6 Importable is a Lua module that allows Roblox developers to use a simple string-based path syntax to access project resources from within their own scripts: local import = require ( script . Parent . Importable ) if game : GetService ( \"RunService\" ): IsClient () then -- Import some instances and modules individually: return { assets = import ( \":StarterPlayer/StarterPlayerScripts/Assets\" ), helpers = import ( \":ReplicatedStorage/Scripts/Lib/Helpers\" ), utils = import ( \":StarterPlayer/StarterPlayerScripts/Scripts/Lib/Utils\" ), } else -- Import multiple resources at once, putting the results into a table: return import . map ({ assets = \":ServerScriptService/Assets\" , helpers = \":ReplicatedStorage/Scripts/Lib/Helpers\" , utils = \":ServerScriptService/Scripts/Lib/Utils\" , }) end Resource Caching \u00b6 Imports are cached by default by Importable, to make importing faster across multiple scripts. Caching behavior can be controlled by invoking Importable with a custom configuration: local import = require ( script . Parent . Importable ). setup ({ isCached = false }) setup instantiates a new instance of Importable, with its own resource cache. To share the same resource cache across all scripts that use Importable, share the same Importable instance among all scripts that need it. Configuration Of Import Behavior \u00b6 A new instance of Importable with customized behavior can be created by invoking the setup method: -- Configure import behavior: local import = require ( script . Parent . Importable ). setup ({ -- Disable resource caching: isCached = false , -- Disable invoking \"require\" on ModuleScript resources: require = false , -- Return nil for missing resources, instead of throwing an error: isStrict = false , }) Import Behavior Overrides \u00b6 The behavior of each import can be controlled individually, if desired: local import = require ( script . Parent . Importable ) -- By default, ModuleScript resources are automatically -- imported using \"require\": local helpers = import ( \":ReplicatedStorage/Scripts/Lib/Helpers\" ) -- To override any import behavior, including \"require\": local helpersInstance = import ( { path = \":ReplicatedStorage/Scripts/Lib/Helpers\" , require = false }) print ( helpers == require ( helpersInstance )) -- true -- \"import.require()\" invokes \"require\" upon a resource, -- but throws an error if the resource is not a ModuleScript: helpers = import . require ( \":ReplicatedStorage/Scripts/Lib/Helpers\" ) -- \"import.get\" bypasses \"require\": helpersInstance = import . get ( \":ReplicatedStorage/Scripts/Lib/Helpers\" ) print ( helpers == require ( helpersInstance )) -- true -- Even multiple resources can be configured independently: return import . map ({ assets = { -- Bypass caching for this resource: path = \":ReplicatedStorage/Assets\" , isCached = false }, helpers = { -- Do not invoke \"require\" upon this resource: path = \":ReplicatedStorage/Scripts/Lib/Helpers\" , require = false }, missing = { -- Do not throw an error if this resource is missing: path = \":ReplicatedStorage/Does-not-exist\" , isStrict = false }, }) Import Aliases \u00b6 Custom aliases can be defined for any import path, providing a convenient notation to refer to arbitrary locations: local import = require ( script . Parent . Importable ). alias ({ -- Assign aliases to common project locations: client = \":StarterPlayer/StarterPlayerScripts/Scripts\" , shared = \":ReplicatedStorage/Scripts\" , server = \":ServerScriptService/Scripts\" , -- Override the \"Assets\" subdirectory from \"client\" and \"shared\": [ \"client/Assets\" ] = \":StarterPlayer/StarterPlayerScripts/Assets\" , [ \"shared/Assets\" ] = \":ReplicatedStorage/Assets\" , }) if game : GetService ( \"RunService\" ): IsClient () then return import . map ({ assets = \"/client/Assets\" , helpers = \"/shared/Lib/Helpers\" , utils = \"/client/Lib/Utils\" , }) else return import . map ({ assets = \"/server/Assets\" , helpers = \"/shared/Lib/Helpers\" , utils = \"/server/Lib/Utils\" , }) end Isomorphic Imports \u00b6 Importable's aliases allow developers to help abstract away the differences between code that runs on the client, and code that runs on the server. Such an approach is known as isomorphic code , and its goal is to help structure an application to follow the same general flow regardless of where the code is executed: local import = require ( script . Parent . Importable ). alias ({ -- Assign aliases to common project locations: client = \":StarterPlayer/StarterPlayerScripts/Scripts\" , shared = \":ReplicatedStorage/Scripts\" , server = \":ServerScriptService/Scripts\" , -- Override the \"Assets\" subdirectory from \"client\" and \"shared\": [ \"client/Assets\" ] = \":StarterPlayer/StarterPlayerScripts/Assets\" , [ \"shared/Assets\" ] = \":ReplicatedStorage/Assets\" , -- Isomorphic alias based on client/server environment: runEnv = game : GetService ( \"RunService\" ): IsClient () and \"/client\" or \"/server\" , }) return import . map ({ assets = \"/runEnv/Assets\" , helpers = \"/shared/Lib/Helpers\" , utils = \"/runEnv/Lib/Utils\" , }) Relative Or Absolute Imports \u00b6 Importing resources by using a path that is relative to some other object in the project hierarchy can be convenient, especially when Importable is used across multiple scripts. Importable offers the from method to specify the root for relative import paths: local import = require ( script . Parent . Importable ). alias ({ -- Assign aliases to common project locations: client = \":StarterPlayer/StarterPlayerScripts/Scripts\" , shared = \":ReplicatedStorage/Scripts\" , server = \":ServerScriptService/Scripts\" , }) -- Use the current script parent as the root for this relative -- import. Relative paths must begin with \"./\" for clarity: local engine = import . from ( script . Parent ). require ( \"./Engine\" ) -- Use the shared library as the root for all relative imports: return import . from ( \"/shared\" ). map ({ -- \"../\" can be used to ascend to the parent of the referenced path: assets = \"../Assets\" , helpers = \"./Helpers\" , }) Robust, Developer-Friendly Error Handling \u00b6 Importable implements error handling around all of its critical operations, ensuring that Importable isn't left in an unusable state after errors occur. Importable errors are reported to the developer in a clear and concise manner via the output console of Roblox Studio. Instead of receiving cryptic error messages such as: ReplicatedStorage.Scripts.Lib.SuperCool:42: invalid argument #1 to 'concat' (table expected, got nil) Importable provides meaningful error messages: ReplicatedStorage.Scripts.Lib.SuperCool:42: Importable alias '/shared/Lib/TableHelper' was neither found nor defined, and strict mode is enabled These error messages are especially helpful for developers who use libraries authored by others. If you intend to write a library to be shared with others, consider using Importable to help your users identify resource import issues more easily. Summary of Benefits \u00b6 Importable offers the following benefits: Simplified Syntax For Importing Project Resources Resource Caching Configuation Of Import Behavior Import Behavior Overrides Import Aliases Isomorphic Imports Relative Or Absolute Imports Robust, Developer-Friendly Error Handling Learn More \u00b6 Read the Installation instructions to learn how to make Resourceful available within your projects. Read the API Reference to learn more about getting started with Resourceful, and how to customize its behavior.","title":"Overview"},{"location":"#importable-overview","text":"","title":"Importable: Overview"},{"location":"#simplified-syntax-for-importing-project-resources","text":"Importable is a Lua module that allows Roblox developers to use a simple string-based path syntax to access project resources from within their own scripts: local import = require ( script . Parent . Importable ) if game : GetService ( \"RunService\" ): IsClient () then -- Import some instances and modules individually: return { assets = import ( \":StarterPlayer/StarterPlayerScripts/Assets\" ), helpers = import ( \":ReplicatedStorage/Scripts/Lib/Helpers\" ), utils = import ( \":StarterPlayer/StarterPlayerScripts/Scripts/Lib/Utils\" ), } else -- Import multiple resources at once, putting the results into a table: return import . map ({ assets = \":ServerScriptService/Assets\" , helpers = \":ReplicatedStorage/Scripts/Lib/Helpers\" , utils = \":ServerScriptService/Scripts/Lib/Utils\" , }) end","title":"Simplified Syntax For Importing Project Resources"},{"location":"#resource-caching","text":"Imports are cached by default by Importable, to make importing faster across multiple scripts. Caching behavior can be controlled by invoking Importable with a custom configuration: local import = require ( script . Parent . Importable ). setup ({ isCached = false }) setup instantiates a new instance of Importable, with its own resource cache. To share the same resource cache across all scripts that use Importable, share the same Importable instance among all scripts that need it.","title":"Resource Caching"},{"location":"#configuration-of-import-behavior","text":"A new instance of Importable with customized behavior can be created by invoking the setup method: -- Configure import behavior: local import = require ( script . Parent . Importable ). setup ({ -- Disable resource caching: isCached = false , -- Disable invoking \"require\" on ModuleScript resources: require = false , -- Return nil for missing resources, instead of throwing an error: isStrict = false , })","title":"Configuration Of Import Behavior"},{"location":"#import-behavior-overrides","text":"The behavior of each import can be controlled individually, if desired: local import = require ( script . Parent . Importable ) -- By default, ModuleScript resources are automatically -- imported using \"require\": local helpers = import ( \":ReplicatedStorage/Scripts/Lib/Helpers\" ) -- To override any import behavior, including \"require\": local helpersInstance = import ( { path = \":ReplicatedStorage/Scripts/Lib/Helpers\" , require = false }) print ( helpers == require ( helpersInstance )) -- true -- \"import.require()\" invokes \"require\" upon a resource, -- but throws an error if the resource is not a ModuleScript: helpers = import . require ( \":ReplicatedStorage/Scripts/Lib/Helpers\" ) -- \"import.get\" bypasses \"require\": helpersInstance = import . get ( \":ReplicatedStorage/Scripts/Lib/Helpers\" ) print ( helpers == require ( helpersInstance )) -- true -- Even multiple resources can be configured independently: return import . map ({ assets = { -- Bypass caching for this resource: path = \":ReplicatedStorage/Assets\" , isCached = false }, helpers = { -- Do not invoke \"require\" upon this resource: path = \":ReplicatedStorage/Scripts/Lib/Helpers\" , require = false }, missing = { -- Do not throw an error if this resource is missing: path = \":ReplicatedStorage/Does-not-exist\" , isStrict = false }, })","title":"Import Behavior Overrides"},{"location":"#import-aliases","text":"Custom aliases can be defined for any import path, providing a convenient notation to refer to arbitrary locations: local import = require ( script . Parent . Importable ). alias ({ -- Assign aliases to common project locations: client = \":StarterPlayer/StarterPlayerScripts/Scripts\" , shared = \":ReplicatedStorage/Scripts\" , server = \":ServerScriptService/Scripts\" , -- Override the \"Assets\" subdirectory from \"client\" and \"shared\": [ \"client/Assets\" ] = \":StarterPlayer/StarterPlayerScripts/Assets\" , [ \"shared/Assets\" ] = \":ReplicatedStorage/Assets\" , }) if game : GetService ( \"RunService\" ): IsClient () then return import . map ({ assets = \"/client/Assets\" , helpers = \"/shared/Lib/Helpers\" , utils = \"/client/Lib/Utils\" , }) else return import . map ({ assets = \"/server/Assets\" , helpers = \"/shared/Lib/Helpers\" , utils = \"/server/Lib/Utils\" , }) end","title":"Import Aliases"},{"location":"#isomorphic-imports","text":"Importable's aliases allow developers to help abstract away the differences between code that runs on the client, and code that runs on the server. Such an approach is known as isomorphic code , and its goal is to help structure an application to follow the same general flow regardless of where the code is executed: local import = require ( script . Parent . Importable ). alias ({ -- Assign aliases to common project locations: client = \":StarterPlayer/StarterPlayerScripts/Scripts\" , shared = \":ReplicatedStorage/Scripts\" , server = \":ServerScriptService/Scripts\" , -- Override the \"Assets\" subdirectory from \"client\" and \"shared\": [ \"client/Assets\" ] = \":StarterPlayer/StarterPlayerScripts/Assets\" , [ \"shared/Assets\" ] = \":ReplicatedStorage/Assets\" , -- Isomorphic alias based on client/server environment: runEnv = game : GetService ( \"RunService\" ): IsClient () and \"/client\" or \"/server\" , }) return import . map ({ assets = \"/runEnv/Assets\" , helpers = \"/shared/Lib/Helpers\" , utils = \"/runEnv/Lib/Utils\" , })","title":"Isomorphic Imports"},{"location":"#relative-or-absolute-imports","text":"Importing resources by using a path that is relative to some other object in the project hierarchy can be convenient, especially when Importable is used across multiple scripts. Importable offers the from method to specify the root for relative import paths: local import = require ( script . Parent . Importable ). alias ({ -- Assign aliases to common project locations: client = \":StarterPlayer/StarterPlayerScripts/Scripts\" , shared = \":ReplicatedStorage/Scripts\" , server = \":ServerScriptService/Scripts\" , }) -- Use the current script parent as the root for this relative -- import. Relative paths must begin with \"./\" for clarity: local engine = import . from ( script . Parent ). require ( \"./Engine\" ) -- Use the shared library as the root for all relative imports: return import . from ( \"/shared\" ). map ({ -- \"../\" can be used to ascend to the parent of the referenced path: assets = \"../Assets\" , helpers = \"./Helpers\" , })","title":"Relative Or Absolute Imports"},{"location":"#robust-developer-friendly-error-handling","text":"Importable implements error handling around all of its critical operations, ensuring that Importable isn't left in an unusable state after errors occur. Importable errors are reported to the developer in a clear and concise manner via the output console of Roblox Studio. Instead of receiving cryptic error messages such as: ReplicatedStorage.Scripts.Lib.SuperCool:42: invalid argument #1 to 'concat' (table expected, got nil) Importable provides meaningful error messages: ReplicatedStorage.Scripts.Lib.SuperCool:42: Importable alias '/shared/Lib/TableHelper' was neither found nor defined, and strict mode is enabled These error messages are especially helpful for developers who use libraries authored by others. If you intend to write a library to be shared with others, consider using Importable to help your users identify resource import issues more easily.","title":"Robust, Developer-Friendly Error Handling"},{"location":"#summary-of-benefits","text":"Importable offers the following benefits: Simplified Syntax For Importing Project Resources Resource Caching Configuation Of Import Behavior Import Behavior Overrides Import Aliases Isomorphic Imports Relative Or Absolute Imports Robust, Developer-Friendly Error Handling","title":"Summary of Benefits"},{"location":"#learn-more","text":"Read the Installation instructions to learn how to make Resourceful available within your projects. Read the API Reference to learn more about getting started with Resourceful, and how to customize its behavior.","title":"Learn More"},{"location":"api-reference/","text":"Importable: API Reference \u00b6 Coming soon! Learn More \u00b6 Read the Overview to learn how Resourceful can solve common resource acquisition problems. Read the Installation instructions to learn how to make Resourceful available within your projects.","title":"API Reference"},{"location":"api-reference/#importable-api-reference","text":"Coming soon!","title":"Importable: API Reference"},{"location":"api-reference/#learn-more","text":"Read the Overview to learn how Resourceful can solve common resource acquisition problems. Read the Installation instructions to learn how to make Resourceful available within your projects.","title":"Learn More"},{"location":"changelog/","text":"Resourceful: Changelog \u00b6 Coming soon! The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#resourceful-changelog","text":"Coming soon! The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Resourceful: Changelog"},{"location":"installation/","text":"Resourceful: Installation \u00b6 Choosing Where To Install Resourceful \u00b6 Within a Roblox Studio project, Resourceful can be installed to a single, shared location where it can be accessed by all project modules that will use it. Conversely, it can also be installed as a child within each module that will use it. Installing Resourceful to a shared location can ensure that a single, known version of Resourceful is used across all modules, while also reducing the file size of the Roblox project. Installing Resourceful as a child within each module that uses Resourceful may help simplify the sharing of such modules with other projects, which can be useful for module libraries. Understanding The Resourceful Search Path \u00b6 When invoking Resourceful with default behavior, Resourceful will automatically search for resources in the parent Instance that contains Resourceful. Thus, if Resourceful is installed to a shared location, invoking that instance of Resourceful with default behavior will search for resources within that shared location. If Resourceful is installed as a child within a module, invoking that instance of Resourceful with default behavior will search for resources within that module. Installing Resourceful to multiple modules would allow each such module to search itself when acquiring resources. Each invocation of Resourceful can also be configured with custom search paths that are as simple or complex as needed. This can allow every module within a project to use a shared instance of Resourceful, while also allowing each module to find the specific resources it needs. Choosing How To Install Resourceful \u00b6 Resourceful can be installed by loading a Resourceful model file into Roblox Studio, or by using a developer tool to synchronize Resourceful's source code into a Roblox Studio project. Loading A Resourceful Model File Into Roblox Studio \u00b6 Obtain the latest version of Resourceful.rbxmx from the GitHub Release Page Insert the model into the chosen parent object(s) within a Roblox Studio project Using A Developer Tool To Synchronize Resourceful \u00b6 Developers who use tools such as Rojo or Remodel can copy the Resourceful source code to the appropriate location(s): Download or clone the source code for Resourceful into a local directory Copy or synchronize the src/Resourceful folder into a Roblox Studio project at the appropriate location(s). Ensure that the new Instance containing Resourceful is named Resourceful . Learn More \u00b6 Read the Overview to learn how Resourceful can solve common resource acquisition problems. Read the API Reference to learn more about getting started with Resourceful, and how to customize its behavior.","title":"Installation"},{"location":"installation/#resourceful-installation","text":"","title":"Resourceful: Installation"},{"location":"installation/#choosing-where-to-install-resourceful","text":"Within a Roblox Studio project, Resourceful can be installed to a single, shared location where it can be accessed by all project modules that will use it. Conversely, it can also be installed as a child within each module that will use it. Installing Resourceful to a shared location can ensure that a single, known version of Resourceful is used across all modules, while also reducing the file size of the Roblox project. Installing Resourceful as a child within each module that uses Resourceful may help simplify the sharing of such modules with other projects, which can be useful for module libraries.","title":"Choosing Where To Install Resourceful"},{"location":"installation/#understanding-the-resourceful-search-path","text":"When invoking Resourceful with default behavior, Resourceful will automatically search for resources in the parent Instance that contains Resourceful. Thus, if Resourceful is installed to a shared location, invoking that instance of Resourceful with default behavior will search for resources within that shared location. If Resourceful is installed as a child within a module, invoking that instance of Resourceful with default behavior will search for resources within that module. Installing Resourceful to multiple modules would allow each such module to search itself when acquiring resources. Each invocation of Resourceful can also be configured with custom search paths that are as simple or complex as needed. This can allow every module within a project to use a shared instance of Resourceful, while also allowing each module to find the specific resources it needs.","title":"Understanding The Resourceful Search Path"},{"location":"installation/#choosing-how-to-install-resourceful","text":"Resourceful can be installed by loading a Resourceful model file into Roblox Studio, or by using a developer tool to synchronize Resourceful's source code into a Roblox Studio project.","title":"Choosing How To Install Resourceful"},{"location":"installation/#loading-a-resourceful-model-file-into-roblox-studio","text":"Obtain the latest version of Resourceful.rbxmx from the GitHub Release Page Insert the model into the chosen parent object(s) within a Roblox Studio project","title":"Loading A Resourceful Model File Into Roblox Studio"},{"location":"installation/#using-a-developer-tool-to-synchronize-resourceful","text":"Developers who use tools such as Rojo or Remodel can copy the Resourceful source code to the appropriate location(s): Download or clone the source code for Resourceful into a local directory Copy or synchronize the src/Resourceful folder into a Roblox Studio project at the appropriate location(s). Ensure that the new Instance containing Resourceful is named Resourceful .","title":"Using A Developer Tool To Synchronize Resourceful"},{"location":"installation/#learn-more","text":"Read the Overview to learn how Resourceful can solve common resource acquisition problems. Read the API Reference to learn more about getting started with Resourceful, and how to customize its behavior.","title":"Learn More"},{"location":"license/","text":"MIT License Copyright (c) 2021 BetterThanReal Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"}]}